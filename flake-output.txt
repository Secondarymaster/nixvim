#FILE ./flake.nix
{
  description = "Simple nixvim config with inheritance-based profiles";
  
  inputs = {
    nixpkgs.url = "github:NixOS/nixpkgs/nixos-unstable";
    nixvim = {
      url = "github:nix-community/nixvim";
      inputs.nixpkgs.follows = "nixpkgs";
    };
  };
  
  outputs = { self, nixpkgs, nixvim, ... }@inputs:
  let
    systems = [ "x86_64-linux" "aarch64-linux" "x86_64-darwin" "aarch64-darwin" ];
    forAllSystems = nixpkgs.lib.genAttrs systems;
    
    # Helper to create nixvim configurations for any system
    makeNixvimFor = system: modules: 
      nixvim.legacyPackages.${system}.makeNixvimWithModule {
        pkgs = nixpkgs.legacyPackages.${system};
        module = { imports = modules; };
      };
  in {
    # Only expose complete, ready-to-use profiles
    nixvimModules = {
      profiles = {
        default = ./modules/profiles/default.nix;
        nix = ./modules/profiles/nix.nix;
      };
    };
    
    # Pre-built packages for all systems
    packages = forAllSystems (system: {
      # Default editor with basic functionality
      default = makeNixvimFor system [ ./modules/profiles/default.nix ];
      
      # Nix-focused editor (inherits default + adds nix support)
      nix = makeNixvimFor system [ ./modules/profiles/nix.nix ];
    });
    
    # Apps for easy running
    apps = forAllSystems (system: {
      default = {
        type = "app";
        program = "${self.packages.${system}.default}/bin/nvim";
      };
      nix = {
        type = "app";
        program = "${self.packages.${system}.nix}/bin/nvim";
      };
    });
    
    # Development shell for working on the config
    devShells = forAllSystems (system: {
      default = nixpkgs.legacyPackages.${system}.mkShell {
        buildInputs = with nixpkgs.legacyPackages.${system}; [
          nixfmt-rfc-style
          nil
        ];
        shellHook = ''
          echo " Nixvim Development Environment"
          echo ""
          echo "Available commands:"
          echo "  nix run .        # Test default profile"
          echo "  nix run .#nix    # Test nix profile"
          echo "  nixfmt **/*.nix  # Format all nix files"
          echo ""
        '';
      };
    });
    
    # Formatter for all systems
    formatter = forAllSystems (system: 
      nixpkgs.legacyPackages.${system}.nixfmt-rfc-style
    );
  };
}

#END
#FILE ./flake-output.txt

#END
#FILE ./modules/core.nix
{
  imports = [
    ./keybinds/core.nix
  ];
  
  config = {
    globals.mapleader = " ";
    
    opts = {
      number = true;
      relativenumber = false;
      expandtab = true;
      shiftwidth = 2;
      tabstop = 2;
      smartindent = true;
      ignorecase = true;
      smartcase = true;
      cursorline = true;
      termguicolors = true;
      signcolumn = "yes";
      splitbelow = true;
      splitright = true;
      clipboard = "unnamedplus";
      mouse = "a";
      undofile = true;
      updatetime = 250;
    };
    
    plugins = {
      treesitter = {
        enable = true;
        settings = {
          highlight.enable = true;
          indent.enable = true;
          ensure_installed = ["vim" "vimdoc" "lua"];
        };
      };
      nvim-autopairs.enable = true;
      comment.enable = true;
      which-key.enable = true;
      lualine = {
        enable = true;
        settings.options.theme = "auto";
      };

      web-devicons.enable = true;
    };
  };
}

#END
#FILE ./modules/keybinds/core.nix
{
  config = {
    keymaps = [
      # Basic operations
      { mode = "n"; key = "<Esc>"; action = "<cmd>noh<CR>"; options.desc = "Clear highlights"; }
      { mode = "n"; key = "<C-s>"; action = "<cmd>w<CR>"; options.desc = "Save file"; }
      
      # Un-map Arrow keys in normal mode
      { mode = "n"; key = "<Up>"; action = "<nop>"; }
      { mode = "n"; key = "<Left>"; action = "<nop>"; }
      { mode = "n"; key = "<Down>"; action = "<nop>"; }
      { mode = "n"; key = "<Right>"; action = "<nop>"; }
      
      # Window navigation
      { mode = "n"; key = "<C-h>"; action = "<C-w>h"; options.desc = "Window left"; }
      { mode = "n"; key = "<C-l>"; action = "<C-w>l"; options.desc = "Window right"; }
      { mode = "n"; key = "<C-j>"; action = "<C-w>j"; options.desc = "Window down"; }
      { mode = "n"; key = "<C-k>"; action = "<C-w>k"; options.desc = "Window up"; }
      
      # Better line movement
      { mode = "n"; key = "j"; action = "v:count == 0 ? 'gj' : 'j'"; options = { expr = true; desc = "Move down"; }; }
      { mode = "n"; key = "k"; action = "v:count == 0 ? 'gk' : 'k'"; options = { expr = true; desc = "Move up"; }; }
    ];
  };
}

#END
#FILE ./modules/keybinds/explorer.nix
{
  config = {
    keymaps = [
      { mode = "n"; key = "<leader>e"; action = "<cmd>NvimTreeToggle<CR>"; options.desc = "Toggle file tree"; }
      { mode = "n"; key = "<leader>ff"; action = "<cmd>Telescope find_files<CR>"; options.desc = "Find files"; }
      { mode = "n"; key = "<leader>fg"; action = "<cmd>Telescope live_grep<CR>"; options.desc = "Live grep"; }
      { mode = "n"; key = "<leader>fb"; action = "<cmd>Telescope buffers<CR>"; options.desc = "Find buffers"; }
      { mode = "n"; key = "<leader>fh"; action = "<cmd>Telescope help_tags<CR>"; options.desc = "Help tags"; }
    ];
  };
}
#END
#FILE ./modules/keybinds/lsp.nix
{
  config = {
    keymaps = [
      { mode = "n"; key = "gd"; action = "<cmd>lua vim.lsp.buf.definition()<CR>"; options.desc = "Go to definition"; }
      { mode = "n"; key = "gr"; action = "<cmd>lua vim.lsp.buf.references()<CR>"; options.desc = "Go to references"; }
      { mode = "n"; key = "K"; action = "<cmd>lua vim.lsp.buf.hover()<CR>"; options.desc = "Hover documentation"; }
      { mode = "n"; key = "<leader>ca"; action = "<cmd>lua vim.lsp.buf.code_action()<CR>"; options.desc = "Code action"; }
      { mode = "n"; key = "<leader>rn"; action = "<cmd>lua vim.lsp.buf.rename()<CR>"; options.desc = "Rename symbol"; }
      { mode = "n"; key = "<leader>f"; action = "<cmd>lua vim.lsp.buf.format({ async = true })<CR>"; options.desc = "Format buffer"; }
      { mode = "n"; key = "[d"; action = "<cmd>lua vim.diagnostic.goto_prev()<CR>"; options.desc = "Previous diagnostic"; }
      { mode = "n"; key = "]d"; action = "<cmd>lua vim.diagnostic.goto_next()<CR>"; options.desc = "Next diagnostic"; }
      { mode = "n"; key = "<leader>d"; action = "<cmd>lua vim.diagnostic.open_float()<CR>"; options.desc = "Show diagnostic"; }
    ];
  };
}
#END
#FILE ./modules/profiles/default/lsp.nix
{
  imports = [ ../../keybinds/lsp.nix ];
  
  config = {
    plugins = {
      lsp = {
        enable = true;
        servers = {
          lua_ls = {
            enable = true;
            settings.Lua = {
              diagnostics.globals = ["vim"];
              workspace.library = [
                "\${3rd}/luv/library"
                "\${3rd}/busted/library"
              ];
            };
          };
        };
      };
      cmp = {
        enable = true;
        settings = {
          snippet.expand = "function(args) require('luasnip').lsp_expand(args.body) end";
          sources = [
            { name = "nvim_lsp"; }
            { name = "luasnip"; }
            { name = "buffer"; }
            { name = "path"; }
          ];
          mapping = {
            "<C-n>" = "cmp.mapping.select_next_item()";
            "<C-p>" = "cmp.mapping.select_prev_item()";
            "<C-y>" = "cmp.mapping.confirm({ select = true })";
            "<C-Space>" = "cmp.mapping.complete()";
          };
        };
      };
      luasnip.enable = true;
      cmp-nvim-lsp.enable = true;
      cmp-buffer.enable = true;
      cmp-path.enable = true;
      cmp_luasnip.enable = true;
    };
  };
}

#END
#FILE ./modules/profiles/default.nix
{
  imports = [
    ../core.nix
    ../themes/catppuccin.nix
    ./default/lsp.nix
    ./default/nvim-tree.nix
    ./default/telescope.nix
  ];
}

#END
#FILE ./modules/profiles/default/nvim-tree.nix
{
  imports = [ ../../keybinds/explorer.nix ];
  
  config = {
    plugins = {
      nvim-tree = {
        enable = true;
        settings = {
          view = {
            width = 30;
            side = "left";
          };
          renderer.group_empty = true;
          filters.dotfiles = false;
        };
      };
    };
  };
}

#END
#FILE ./modules/profiles/default/telescope.nix
{
  imports = [ ../../keybinds/explorer.nix ];
  
  config = {
    plugins = {
      telescope = {
        enable = true;
        settings = {
          defaults = {
            layout_strategy = "horizontal";
            layout_config = {
              preview_width = 0.6;
            };
            file_ignore_patterns = [
              "node_modules"
              ".git/"
              "target/"
              "result"
            ];
          };
        };
      };
    };
  };
}

#END
#FILE ./modules/profiles/nix/lsp.nix
{
  config = {
    plugins = {
      lsp.servers.nil_ls = {
        enable = true;
        settings.nil = {
          formatting.command = ["nixfmt"];
          nix.flake.autoArchive = true;
        };
      };
      treesitter.settings.ensure_installed = ["nix"];
    };
    
    autoCmd = [
      {
        event = ["BufRead" "BufNewFile"];
        pattern = ["*.nix"];
        callback.__raw = ''
          function()
            vim.opt_local.tabstop = 2
            vim.opt_local.shiftwidth = 2
            vim.opt_local.expandtab = true
            vim.opt_local.commentstring = "# %s"
          end
        '';
      }
    ];
  };
}

#END
#FILE ./modules/profiles/nix.nix
{
  imports = [
    ./default.nix
    ./nix/lsp.nix
  ];
}

#END
#FILE ./modules/themes/catppuccin.nix
{
  config = {
    colorschemes.catppuccin = {
      enable = true;
      settings = {
        flavour = "mocha"; # mocha, macchiato, frappe, latte
        background = {
          light = "latte";
          dark = "mocha";
        };
        transparent_background = false;
        show_end_of_buffer = false;
        term_colors = true;
        dim_inactive = {
          enabled = false;
          shade = "dark";
          percentage = 0.15;
        };
        no_italic = false;
        no_bold = false;
        no_underline = false;
        styles = {
          comments = ["italic"];
          conditionals = ["italic"];
          loops = [];
          functions = [];
          keywords = [];
          strings = [];
          variables = [];
          numbers = [];
          booleans = [];
          properties = [];
          types = [];
          operators = [];
        };
        color_overrides = {};
        custom_highlights = {};
        integrations = {
          cmp = true;
          gitsigns = true;
          nvimtree = true;
          treesitter = true;
          notify = false;
          mini = {
            enabled = true;
            indentscope_color = "";
          };
          telescope = {
            enabled = true;
          };
          which_key = true;
        };
      };
    };
    
    # Set the colorscheme
    extraConfigLua = ''
      vim.cmd.colorscheme "catppuccin"
    '';
  };
}
#END
#FILE ./modules/themes/pywal.nix
{
  config = {
    # Disable other colorschemes when using pywal
    colorschemes = {
      catppuccin.enable = false;
    };
    
    # Use pywal colors
    extraConfigLua = ''
      -- Load pywal colors
      local function load_pywal_colors()
        local colors_file = os.getenv("HOME") .. "/.cache/wal/colors-wal.vim"
        local file = io.open(colors_file, "r")
        
        if file then
          file:close()
          vim.cmd("source " .. colors_file)
          return true
        else
          -- Fallback if pywal hasn't generated colors yet
          vim.notify("Pywal colors not found, using fallback", vim.log.levels.WARN)
          vim.cmd.colorscheme("default")
          return false
        end
      end
      
      -- Try to load pywal colors
      if not load_pywal_colors() then
        -- Create basic dark theme as fallback
        vim.o.background = "dark"
      end
      
      -- Auto-reload when pywal colors change
      vim.api.nvim_create_autocmd("Signal", {
        pattern = "SIGUSR1",
        callback = function()
          load_pywal_colors()
          vim.notify("Pywal colors reloaded!", vim.log.levels.INFO)
        end,
      })
    '';
    
    # Optional: Set up pywal integration for lualine
    plugins.lualine = {
      enable = true;
      settings = {
        options = {
          theme = "auto"; # Will pick up pywal colors
          component_separators = "|";
          section_separators = "";
        };
      };
    };
  };
}
#END
